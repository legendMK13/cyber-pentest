from flask import Flask, render_template, request, redirect, url_for, send_from_directory, make_response
import sqlite3
import re
import bcrypt
import datetime

app = Flask(__name__)

# Hookup stylesheet
@app.route('/style.css')
def style():
    return send_from_directory('templates', 'style.css')


# Password checker to ensure we have requirements
def password_check(password):
    if len(password) < 8:
        return False
    elif not re.search("[a-zA-Z]", password):
        return False
    elif not re.search("[A-Z]", password):
        return False
    else:
        return True

#Creates user database
def create_database():
    conn = sqlite3.connect('users.db')
    c = conn.cursor()
    c.execute('DROP TABLE IF EXISTS users')
    c.execute('''
        CREATE TABLE users (
            id INTEGER PRIMARY KEY,
            username TEXT NOT NULL,
            password TEXT NOT NULL,
            salt TEXT NOT NULL
        )
    ''')
    conn.commit()
    conn.close()

# Function to create the IP address table
def create_ip_address_table():
    conn = sqlite3.connect('ip.db')
    c = conn.cursor()
    c.execute('DROP TABLE IF EXISTS ip_address')
    c.execute('''
        CREATE TABLE ip_address (
            ip TEXT PRIMARY KEY,
            failed_attempts INTEGER DEFAULT 0,
            blocked_until TEXT DEFAULT NULL
        )
    ''')
    conn.commit()
    conn.close()

# Function to check if an IP address is currently blocked
def is_blocked(ip_address):
    conn = sqlite3.connect('ip.db')
    c = conn.cursor()
    c.execute('SELECT blocked_until FROM ip_address WHERE ip = ?', (ip_address,))
    blocked_until = c.fetchone()
    conn.close()

    if blocked_until and blocked_until[0]:
        # Remove any remaining microseconds from the timestamp
        blocked_until = blocked_until[0].split('.')[0]
        if datetime.datetime.now() < datetime.datetime.strptime(blocked_until, '%Y-%m-%d %H:%M:%S'):
            return True
    return False

# Function to update the failed log-in attempts for an IP address
def update_failed_attempts(ip_address):
    conn = sqlite3.connect('ip.db')
    c = conn.cursor()
    blocked_until = None

    # Check if the IP address is already blocked
    if is_blocked(ip_address):
        return False

    # Increment the failed log-in attempts
    c.execute('SELECT failed_attempts FROM ip_address WHERE ip = ?', (ip_address,))
    failed_attempts = c.fetchone()

    if failed_attempts:
        failed_attempts = failed_attempts[0] + 1
        if failed_attempts >= 3:
            # Block the IP address for 1 minutes
            blocked_until = datetime.datetime.now() + datetime.timedelta(minutes=1)
    else:
        failed_attempts = 1

    c.execute('INSERT OR REPLACE INTO ip_address (ip, failed_attempts, blocked_until) VALUES (?, ?, ?)', (ip_address, failed_attempts, blocked_until))
    conn.commit()
    conn.close()

    return True

def add_user(username, password):
    # Generate a random salt
    salt = bcrypt.gensalt()

    # Hash the password with the salt
    hashed_password = bcrypt.hashpw(password.encode('utf-8'), salt)

    conn = sqlite3.connect('users.db')
    c = conn.cursor()
    c.execute("INSERT INTO users (username, password, salt) VALUES (?,?,?)", (username, hashed_password, salt))
    #c.execute("SELECT * FROM users WHERE username='" + username + "' AND password='" + password + "'")
    ## The above statement is more prone to SQL injection because it can allow for SQL queries through concat.
    ### The addition of the salt allows for

    conn.commit()
    conn.close()

def get_user(username, password):
    conn = sqlite3.connect('users.db')
    c = conn.cursor()
    c.execute("SELECT * FROM users WHERE username=?", (username,))
    user = c.fetchone()
    conn.close()

    # Check if user exists and verify password
    if user and bcrypt.checkpw(password.encode('utf-8'), user[2]):
        return user
    else:
        return None

@app.route('/')
def index():
    response = make_response(render_template("index.html"))
    return response

@app.route("/signup", methods=["GET", "POST"])
def signup():
    if request.method == "POST":
        username = request.form.get("username")
        password = request.form.get("password")
        if password_check(password):
            add_user(username, password)
            return redirect("/")
        else:
            return render_template("signup.html", error="Password must be at least 8 characters, include 1 letter, and 1 uppercase letter.")
    return render_template("signup.html")

# Login route
@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        ip_address = request.remote_addr  # Get the user's IP address from the request object

        # Check if the IP address is blocked
        if is_blocked(ip_address):
            error = "Too many failed log-in attempts. This IP address has been temporarily blocked."
            return render_template('login.html', error=error)

        user = get_user(username, password)

        if user:
            # Reset the failed log-in attempts for this IP address
            conn = sqlite3.connect('users.db')
            c = conn.cursor()
            c.execute('UPDATE ip_address SET failed_attempts = 0 WHERE ip = ?', (ip_address,))
            conn.commit()
            conn.close()

            return redirect(url_for('user', username=username))
        else:
            # Increment the failed log-in attempts for this IP address
            update_failed_attempts(ip_address)
            error = "Invalid username or password. Please try again."

            # Set countdown timer of 5 seconds to prevent against brute-force attacks
            return render_template('login.html', error=error, countdown=5)

    return render_template('login.html')

@app.route('/user/<username>')
def user(username):
    return f'Hello, {username}!'

if __name__ == '__main__':
    create_database()
    create_ip_address_table()
    app.run(debug=True)
